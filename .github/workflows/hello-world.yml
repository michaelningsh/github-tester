name: Hello World

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:   # æ‰‹åŠ¨è§¦å‘

jobs:
  hello:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Say Hello
        run: echo "ðŸŽ‰ Hello, World! GitHub Actions is working!"

  fetch-rpms:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        gpu-driver: [true, false]
    outputs:
      result_gpu: ${{ steps.export-gpu-result.outputs.output_content }}
      result_nogpu: ${{ steps.export-nogpu-result.outputs.output_content }}
      
    steps:
      - name: Checkout # å¿…é¡»å…ˆæ£€å‡ºä»“åº“æ‰èƒ½è®¿é—®æ¨¡æ‹Ÿæ–‡ä»¶
        uses: actions/checkout@v4 # ä½¿ç”¨ v4 æˆ–æ‚¨æŒ‡å®šçš„ SHA
        with:
          fetch-depth: 0

      # æ¨¡æ‹Ÿæ—¶ä¸éœ€è¦ JFrog CLIï¼Œå¦‚æžœå…¶ä»–éƒ¨åˆ†éœ€è¦å¯ä»¥ä¿ç•™
      # - name: Setup JFrog CLI
      #   uses: jfrog/setup-jfrog-cli@v4
      #   env:
      #     JF_URL: https://artifactory-ehv.ta.philips.com/
      #     JF_USER: ${{ secrets.ARTIFACTORY_USERNAME }}
      #     JF_PASSWORD: ${{ secrets.ARTIFACTORY_APIKEY }}

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libguestfs-tools
          sudo apt-get install -y tree

      - name: Prepare dynamic variables
        id: prep
        run: |
          if [[ "${{ matrix.gpu-driver }}" == "true" ]]; then
            SUFFIX=""
            TYPE="gpu"
            echo "initial_os_updates_yaml=./os-updates.yaml" >> $GITHUB_OUTPUT
            echo "mock_updates_xml=./mock_data/updates_gpu.xml" >> $GITHUB_OUTPUT
          else
            SUFFIX="--no-gpu"
            TYPE="no-gpu"
            echo "initial_os_updates_yaml=./os-updates--no-gpu.yaml" >> $GITHUB_OUTPUT
            echo "mock_updates_xml=./mock_data/updates_no_gpu.xml" >> $GITHUB_OUTPUT
          fi
          echo "image_suffix=${SUFFIX}" >> $GITHUB_OUTPUT
          echo "image_type=${TYPE}" >> $GITHUB_OUTPUT
          echo "base_image=lws-base-image${SUFFIX}" >> $GITHUB_OUTPUT
          echo "output_file=os-updates${SUFFIX}.yaml" >> $GITHUB_OUTPUT


      - name: Prepare workdir
        run: |
            mkdir -p ./tmp/${{ steps.prep.outputs.image_type }}/output
            # è¿˜è¦åˆ›å»ºåˆå§‹çš„ os-updates.yaml æ–‡ä»¶åˆ°æœŸæœ›çš„ä½ç½®ï¼Œä»¥ä¾¿åŽç»­åˆå¹¶
            # è¿™é‡Œå‡è®¾ `output_file` æ˜¯æœ€ç»ˆè¢« Base64 ç¼–ç çš„æ–‡ä»¶åï¼Œ
            # ä¸”æˆ‘ä»¬å¸Œæœ›æŠŠåŽŸå§‹æ–‡ä»¶å¤åˆ¶åˆ° `tmp/${{ steps.prep.outputs.image_type }}/` ä¸‹ï¼Œå¹¶ä»¥ `output_file` å‘½å
            # å› ä¸º `Merge existing with new OS updates` æ­¥éª¤ä¸­ `eval(strenv(originalPath))` å¼•ç”¨çš„æ˜¯ ${{ steps.prep.outputs.output_file }}
            # æˆ‘ä»¬éœ€è¦ç¡®ä¿è¿™ä¸ªæ–‡ä»¶å­˜åœ¨
            cp ${{ steps.prep.outputs.initial_os_updates_yaml }} ./tmp/${{ steps.prep.outputs.image_type }}/${{ steps.prep.outputs.output_file }}

      # ç§»é™¤ Download and decompress RAW image from Artifactory

      # ç§»é™¤ Build Docker image from rootfs
        
      - name: Simulate Run list-os-updates.sh in container (copy mock XML)
        run: |
          # ç›´æŽ¥å°†æ¨¡æ‹Ÿçš„ updates.xml å¤åˆ¶åˆ° /output ç›®å½•
          cp ${{ steps.prep.outputs.mock_updates_xml }} ./tmp/${{ steps.prep.outputs.image_type }}/output/updates.xml
          echo "[âœ“] Simulated. RPM update list is in tmp/${{ steps.prep.outputs.image_type }}/output/updates.xml"
          tree tmp/${{ steps.prep.outputs.image_type }}/

      - name: Convert new updates to Yaml
        id: convert
        uses: mikefarah/yq@v4.46.1
        with:
          cmd: |
            yq -px -oy '{"updates": [.stream.update-status.update-list.update[] | {"name": .["+@name"], "version": .["+@edition"] | split("-") | .[0] }]}' \
              tmp/${{ steps.prep.outputs.image_type }}/output/updates.xml
 
      - name: Save updates.yaml
        run: |
          echo '${{ steps.convert.outputs.result }}' \
            > tmp/${{ steps.prep.outputs.image_type }}/output/updates.yaml
          tree tmp/${{ steps.prep.outputs.image_type }}/
            
      - name: Merge existing with new OS updates
        uses: mikefarah/yq@v4.46.1
        with:
          cmd: |
            idPath=".name"  originalPath=".updates"  otherPath=".updates" yq eval-all --inplace '
            (
              (( (eval(strenv(originalPath)) + eval(strenv(otherPath)))  | .[] | {(eval(strenv(idPath))):  .}) as $item ireduce ({}; . * $item )) as $uniqueMap
              | ( $uniqueMap  | to_entries | .[]) as $item ireduce([]; . + $item.value)
            ) as $mergedArray
            | select(fi == 0) | (eval(strenv(originalPath))) = $mergedArray
            ' tmp/${{ steps.prep.outputs.image_type }}/${{ steps.prep.outputs.output_file }} tmp/${{ steps.prep.outputs.image_type }}/output/updates.yaml

      - name: Encode GPU file and set as job output
        id: export-gpu-result # æ–°å¢ž ID
        if: ${{ matrix.gpu-driver == true }} # ä»…åœ¨ gpu-driver ä¸º true æ—¶è¿è¡Œ
        run: |
          echo "==== Final merged YAML for GPU ===="
          cat tmp/${{ steps.prep.outputs.image_type }}/${{ steps.prep.outputs.output_file }}
          ENCODED_STRING=$(base64 -w 0 tmp/${{ steps.prep.outputs.image_type }}/${{ steps.prep.outputs.output_file }})
          JSON_PAYLOAD=$(jq -cn --arg name "${{ steps.prep.outputs.output_file }}" --arg content "$ENCODED_STRING" '{file_name: $name, file_content_base_64: $content}')          
          # è®¾ç½®æ­¤æ­¥éª¤çš„è¾“å‡ºï¼Œç„¶åŽ Job çš„ outputs å¼•ç”¨æ­¤æ­¥éª¤è¾“å‡º
          echo "output_content=$JSON_PAYLOAD" >> $GITHUB_OUTPUT
          echo "DEBUG: Setting Step Output for GPU: $JSON_PAYLOAD"

      - name: Encode No-GPU file and set as job output
        id: export-nogpu-result # æ–°å¢ž ID
        if: ${{ matrix.gpu-driver == false }} # ä»…åœ¨ gpu-driver ä¸º false æ—¶è¿è¡Œ
        run: |
          echo "==== Final merged YAML for No-GPU ===="
          cat tmp/${{ steps.prep.outputs.image_type }}/${{ steps.prep.outputs.output_file }}
          ENCODED_STRING=$(base64 -w 0 tmp/${{ steps.prep.outputs.image_type }}/${{ steps.prep.outputs.output_file }})
          JSON_PAYLOAD=$(jq -cn --arg name "${{ steps.prep.outputs.output_file }}" --arg content "$ENCODED_STRING" '{file_name: $name, file_content_base_64: $content}')          
          # è®¾ç½®æ­¤æ­¥éª¤çš„è¾“å‡ºï¼Œç„¶åŽ Job çš„ outputs å¼•ç”¨æ­¤æ­¥éª¤è¾“å‡º
          echo "output_content=$JSON_PAYLOAD" >> $GITHUB_OUTPUT
          echo "DEBUG: Setting Step Output for No-GPU: $JSON_PAYLOAD"


  create-pr:
    needs: [fetch-rpms]
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v4.1.7

      - name: Setup jq
        uses: dcarbone/install-jq-action@v3.2.0

      - name: Restore YAML files from matrix outputs
        run: |
          echo "--- Starting: Restore YAML files from matrix outputs ---"

          echo "[Step 1/5] Getting the raw JSON outputs from the 'fetch-rpms' job..."
          
          # ç›´æŽ¥èŽ·å– result_gpu å’Œ result_nogpu çš„è¾“å‡º
          # å®ƒä»¬å·²ç»æ˜¯å­—ç¬¦ä¸²å½¢å¼çš„ JSONï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ fromjson è½¬æ¢
          GPU_RAW_OUTPUT='${{ needs.fetch-rpms.outputs.result_gpu }}'
          NOGPU_RAW_OUTPUT='${{ needs.fetch-rpms.outputs.result_nogpu }}'
          
          # å°†è¿™ä¸¤ä¸ªåŽŸå§‹ JSON å­—ç¬¦ä¸²è§£æžæˆ JSON å¯¹è±¡ï¼Œå¹¶ç»„åˆæˆä¸€ä¸ª JSON æ•°ç»„
          OUTPUTS_ARRAY=$(echo "$GPU_RAW_OUTPUT" | jq fromjson ; echo "$NOGPU_RAW_OUTPUT" | jq fromjson )
          OUTPUTS_ARRAY=$(echo "$OUTPUTS_ARRAY" | jq -s '.')


          echo "Processed JSON Array (should contain two objects):"
          echo "$OUTPUTS_ARRAY"
          echo "--------------------------------------------------"

          echo "[Step 2/5] Using jq to extract Base64 encoded file content..."
          # çŽ°åœ¨ OUTPUTS_ARRAY æ˜¯ä¸€ä¸ªçœŸæ­£çš„ JSON æ•°ç»„ï¼Œå¯ä»¥ç›´æŽ¥æŸ¥è¯¢
          GPU_B64=$(echo "$OUTPUTS_ARRAY" | jq -r '.[] | select(.file_name=="os-updates.yaml") | .file_content_base_64')
          NOGPU_B64=$(echo "$OUTPUTS_ARRAY" | jq -r '.[] | select(.file_name=="os-updates--no-gpu.yaml") | .file_content_base_64')

          # æ‰“å°ä¸€ä¸ªæ‘˜è¦ä»¥ä¾›è°ƒè¯•
          echo "Extracted content for 'os-updates.yaml' (first 50 chars): $(echo -n "$GPU_B64" | head -c 50)..."
          echo "Extracted content for 'os-updates--no-gpu.yaml' (first 50 chars): $(echo -n "$NOGPU_B64" | head -c 50)..."
          echo "--------------------------------------------------"

          echo "[Step 3/5] Restoring os-updates.yaml..."
          if [[ -n "$GPU_B64" ]]; then
            echo "$GPU_B64" | base64 --decode > os-updates.yaml
            echo "Successfully created the os-updates.yaml file."
          else
            echo "::error::Failed to find or extract the output content for 'os-updates.yaml'."
            exit 1
          fi
          echo "--------------------------------------------------"

          echo "[Step 4/5] Restoring os-updates--no-gpu.yaml..."
          if [[ -n "$NOGPU_B64" ]]; then
            echo "$NOGPU_B64" | base64 --decode > os-updates--no-gpu.yaml
            echo "Successfully created the os-updates--no-gpu.yaml file."
          else
            echo "::error::Failed to find or extract the output content for 'os-updates--no-gpu.yaml'."
            exit 1
          fi
          echo "--------------------------------------------------"

          echo "[Step 5/5] Verifying the restored files..."
          ls -l os-updates*.yaml
          echo "--- Finished: YAML files restored successfully ---"
